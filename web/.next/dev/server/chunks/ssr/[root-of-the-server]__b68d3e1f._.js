module.exports = [
"[project]/src/app/favicon.ico.mjs { IMAGE => \"[project]/src/app/favicon.ico (static in ecmascript, tag client)\" } [app-rsc] (structured image object, ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/src/app/favicon.ico.mjs { IMAGE => \"[project]/src/app/favicon.ico (static in ecmascript, tag client)\" } [app-rsc] (structured image object, ecmascript)"));
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[project]/src/app/layout.tsx [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/src/app/layout.tsx [app-rsc] (ecmascript)"));
}),
"[project]/src/components/HomePageClient.tsx [app-rsc] (client reference proxy) <module evaluation>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
// This file is generated by next-core EcmascriptClientReferenceModule.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
;
const __TURBOPACK__default__export__ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call the default export of [project]/src/components/HomePageClient.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/src/components/HomePageClient.tsx <module evaluation>", "default");
}),
"[project]/src/components/HomePageClient.tsx [app-rsc] (client reference proxy)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
// This file is generated by next-core EcmascriptClientReferenceModule.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
;
const __TURBOPACK__default__export__ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call the default export of [project]/src/components/HomePageClient.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/src/components/HomePageClient.tsx", "default");
}),
"[project]/src/components/HomePageClient.tsx [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$components$2f$HomePageClient$2e$tsx__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/src/components/HomePageClient.tsx [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$components$2f$HomePageClient$2e$tsx__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/src/components/HomePageClient.tsx [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$components$2f$HomePageClient$2e$tsx__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/src/config/layoutConfig.ts [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LAYOUT_CONFIG",
    ()=>LAYOUT_CONFIG
]);
const LAYOUT_CONFIG = {
    grid: {
        totalColumns: 10,
        cellHeight: 10,
        gap: 4
    },
    // Content Weight Factors for Volume Calculation
    // Volume = (Score * scoreWeight)
    volumeFactors: {
        scoreWeight: 3.0,
        textWeight: 0.0
    },
    // Grid Constraints
    constraints: {
        minWidth: 3,
        maxWidth: 8,
        minHeight: 2
    },
    // Shape Efficiency: Adjusts height based on text wrapping efficiency
    // Narrow cards wrap more (Inefficient) -> Need more height (Divide by < 1.0)
    // Wide cards wrap less (Efficient) -> Need less height (Divide by > 1.0)
    shapeEfficiency: {
        narrowThreshold: 3,
        narrowFactor: 0.9,
        wideThreshold: 6,
        wideFactor: 1.1,
        standardFactor: 1.0
    },
    // Physics Constants for Exact Text Fit
    physics: {
        colWidthPx: 116,
        lineHeightPx: 24,
        charWidthPx: 11,
        paddingPx: 40,
        headerHeightPx: 100
    },
    // Content display rules (Line Clamping)
    corrections: {
        lineClamp: [
            {
                minRatio: 2.0,
                minRows: 0,
                lines: 8
            },
            {
                minRatio: 1.4,
                minRows: 3,
                lines: 6
            },
            {
                minRatio: 1.0,
                minRows: 0,
                lines: 5
            },
            {
                minRatio: 0.0,
                minRows: 4,
                lines: 5
            },
            {
                minRatio: 0.0,
                minRows: 0,
                lines: 3
            }
        ]
    }
};
}),
"[project]/src/utils/layoutOptimizer.ts [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LayoutOptimizer",
    ()=>LayoutOptimizer,
    "getLayoutOptimizer",
    ()=>getLayoutOptimizer,
    "optimizeArticleOrder",
    ()=>optimizeArticleOrder
]);
/**
 * Layout Optimizer - Gap-Filling Algorithm
 * 
 * Simulates CSS Grid layout, detects empty spaces (gaps),
 * and recommends high ZS-score articles to fill those gaps.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$config$2f$layoutConfig$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/config/layoutConfig.ts [app-rsc] (ecmascript)");
;
// Deterministic hash for consistent width selection
const getHash = (str)=>{
    if (!str) return 0;
    let hash = 0;
    for(let i = 0; i < str.length; i++){
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
    }
    return Math.abs(hash);
};
// Calculate article size using the same physics logic as ArticleDisplay
const calculateArticleSize = (article)=>{
    const { constraints, physics, grid } = __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$config$2f$layoutConfig$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["LAYOUT_CONFIG"];
    const textLength = (article.summary || '').length;
    const score = article.impact_score || 0;
    const minW = constraints.minWidth;
    const maxW = constraints.maxWidth;
    // Random width based on ID hash
    const hash = getHash(article.id || '');
    const widthRange = maxW - minW + 1;
    let cols = minW + hash % widthRange;
    // High impact bias
    if (score >= 7.0) {
        cols = Math.max(cols, 6);
    }
    cols = Math.min(cols, maxW);
    // Physics calculation
    const availableWidthPx = cols * physics.colWidthPx - physics.paddingPx - (cols - 1) * grid.gap;
    const charsPerLine = availableWidthPx / physics.charWidthPx;
    const estimatedLines = Math.ceil(textLength / charsPerLine);
    const requiredHeightPx = physics.headerHeightPx + estimatedLines * physics.lineHeightPx + physics.paddingPx;
    // Grid quantization (10px steps)
    const gapPx = 16;
    const trackPx = grid.cellHeight;
    let rows = Math.ceil((requiredHeightPx + gapPx) / (trackPx + gapPx));
    // Safety Margin: Add 2 extra rows to prevent text cutoff
    rows = rows + 2;
    // Minimal floor
    const MIN_ROWS = 5;
    rows = Math.max(rows, MIN_ROWS);
    rows = Math.min(rows, 80);
    return {
        cols,
        rows
    };
};
class LayoutOptimizer {
    gridCols;
    gridRows;
    grid;
    placements;
    nextRow;
    constructor(gridCols = 10, initialRows = 100){
        this.gridCols = gridCols;
        this.gridRows = initialRows;
        this.grid = this.createEmptyGrid(gridCols, initialRows);
        this.placements = [];
        this.nextRow = 0;
    }
    createEmptyGrid(cols, rows) {
        return Array.from({
            length: rows
        }, ()=>Array.from({
                length: cols
            }, ()=>({
                    occupied: false
                })));
    }
    expandGridIfNeeded(requiredRows) {
        while(this.gridRows < requiredRows){
            this.grid.push(Array.from({
                length: this.gridCols
            }, ()=>({
                    occupied: false
                })));
            this.gridRows++;
        }
    }
    // Find first available position for an article (left-to-right, top-to-bottom)
    findPosition(cols, rows, minRow = 0) {
        for(let r = minRow; r < this.gridRows; r++){
            for(let c = 0; c <= this.gridCols - cols; c++){
                if (this.canPlace(c, r, cols, rows)) {
                    return {
                        col: c,
                        row: r
                    };
                }
            }
            // Expand grid if we've searched too far
            if (r >= this.gridRows - rows - 1) {
                this.expandGridIfNeeded(this.gridRows + 10);
            }
        }
        // Fallback: append at end
        const newRow = Math.max(this.gridRows, minRow);
        this.expandGridIfNeeded(newRow + rows);
        return {
            col: 0,
            row: newRow
        };
    }
    canPlace(col, row, cols, rows) {
        this.expandGridIfNeeded(row + rows);
        for(let r = row; r < row + rows; r++){
            for(let c = col; c < col + cols; c++){
                if (c >= this.gridCols) return false;
                if (this.grid[r][c].occupied) return false;
            }
        }
        return true;
    }
    markOccupied(col, row, cols, rows, articleId) {
        this.expandGridIfNeeded(row + rows);
        for(let r = row; r < row + rows; r++){
            for(let c = col; c < col + cols; c++){
                this.grid[r][c] = {
                    occupied: true,
                    articleId
                };
            }
        }
        this.nextRow = Math.max(this.nextRow, row + rows);
    }
    // Place an article in the grid
    placeArticle(article, minRow = 0) {
        const pos = this.findPosition(article.cols, article.rows, minRow);
        if (!pos) return null;
        this.markOccupied(pos.col, pos.row, article.cols, article.rows, article.id);
        const placement = {
            article,
            ...pos
        };
        this.placements.push(placement);
        return placement;
    }
    // Detect gaps (empty rectangular regions)
    detectGaps(minArea = 6) {
        const gaps = [];
        const visited = new Set();
        for(let r = 0; r < this.nextRow; r++){
            for(let c = 0; c < this.gridCols; c++){
                const key = `${c},${r}`;
                if (visited.has(key) || this.grid[r][c].occupied) continue;
                // Find largest rectangle starting from this cell
                const gap = this.findLargestGap(c, r, visited);
                if (gap && gap.area >= minArea) {
                    gaps.push(gap);
                }
            }
        }
        return gaps.sort((a, b)=>b.area - a.area); // Largest first
    }
    findLargestGap(startCol, startRow, visited) {
        // Find max width
        let maxWidth = 0;
        for(let c = startCol; c < this.gridCols; c++){
            if (this.grid[startRow][c].occupied) break;
            maxWidth++;
        }
        // Find max height maintaining width
        let maxHeight = 0;
        let currentWidth = maxWidth;
        for(let r = startRow; r < this.nextRow; r++){
            let rowWidth = 0;
            for(let c = startCol; c < startCol + currentWidth; c++){
                if (this.grid[r][c].occupied) break;
                rowWidth++;
            }
            if (rowWidth === 0) break;
            currentWidth = Math.min(currentWidth, rowWidth);
            maxHeight++;
        }
        // Mark visited
        for(let r = startRow; r < startRow + maxHeight; r++){
            for(let c = startCol; c < startCol + currentWidth; c++){
                visited.add(`${c},${r}`);
            }
        }
        return {
            col: startCol,
            row: startRow,
            width: currentWidth,
            height: maxHeight,
            area: currentWidth * maxHeight
        };
    }
    // Find best article to fill a gap (ZS score priority)
    findFillerForGap(gap, candidates) {
        // Filter articles that fit in the gap
        const fittingArticles = candidates.filter((a)=>a.cols <= gap.width && a.rows <= gap.height);
        if (fittingArticles.length === 0) return null;
        // Sort by ZS score (lower is better), then by how well it fills the gap
        fittingArticles.sort((a, b)=>{
            // Primary: ZS score (ascending - lower is better quality)
            const zsDiff = a.zeroEchoScore - b.zeroEchoScore;
            if (Math.abs(zsDiff) > 0.5) return zsDiff;
            // Secondary: Fill efficiency (prefer articles that fill more of the gap)
            const fillA = a.cols * a.rows / gap.area;
            const fillB = b.cols * b.rows / gap.area;
            return fillB - fillA;
        });
        return fittingArticles[0] || null;
    }
    // Main optimization function
    optimizeLayout(articles) {
        // Reset grid completely
        this.gridRows = 100;
        this.grid = this.createEmptyGrid(this.gridCols, this.gridRows);
        this.placements = [];
        this.nextRow = 0;
        // Calculate sizes for all articles
        // IMPORTANT: Use url as ID since articles may not have a dedicated 'id' field
        const articlesWithSize = articles.map((a, index)=>({
                ...a,
                id: a.id || a.url || `article-${index}`,
                ...calculateArticleSize(a),
                zeroEchoScore: a.zero_echo_score || 0,
                impactScore: a.impact_score || 0
            }));
        // Sort by Combined Score (primary placement order)
        // Award winners will be placed first in Phase 0, then remaining by this order
        const sortedArticles = [
            ...articlesWithSize
        ].sort((a, b)=>{
            const combinedA = 10 - a.zeroEchoScore + a.impactScore;
            const combinedB = 10 - b.zeroEchoScore + b.impactScore;
            return combinedB - combinedA;
        });
        const placed = new Set();
        const finalOrder = [];
        // ===== AWARD SYSTEM =====
        // 1. Today's Headline: Best Combined Score (10 - ZS) + IS
        // 2. Zero Echo Award: Lowest ZS (tiebreaker: highest IS)
        // 3. Hot Topic: Highest IS
        // NOTE: All articles are eligible for awards (tags are optional)
        // ëª¨ë“  ê¸°ì‚¬ê°€ ì–´ì›Œë“œ í›„ë³´ (íƒœê·¸ ìœ ë¬´ ê´€ê³„ì—†ì´)
        const awardCandidates = articlesWithSize;
        // Find award winners (only from candidates with tags)
        const byCombo = [
            ...awardCandidates
        ].sort((a, b)=>{
            const combinedA = 10 - a.zeroEchoScore + a.impactScore;
            const combinedB = 10 - b.zeroEchoScore + b.impactScore;
            return combinedB - combinedA;
        });
        const byZS = [
            ...awardCandidates
        ].sort((a, b)=>{
            const zsDiff = a.zeroEchoScore - b.zeroEchoScore; // Lower is better
            if (Math.abs(zsDiff) < 0.01) {
                return b.impactScore - a.impactScore; // Tiebreaker: higher IS
            }
            return zsDiff;
        });
        const byIS = [
            ...awardCandidates
        ].sort((a, b)=>b.impactScore - a.impactScore);
        // Assign awards (an article can win multiple)
        const awardMap = new Map();
        const addAward = (articleId, award)=>{
            if (!awardMap.has(articleId)) {
                awardMap.set(articleId, []);
            }
            awardMap.get(articleId).push(award);
        };
        // Assign primary awards
        if (byCombo.length > 0) addAward(byCombo[0].id, "Today's Headline");
        if (byZS.length > 0) addAward(byZS[0].id, "Zero Echo Award");
        if (byIS.length > 0) addAward(byIS[0].id, "Hot Topic");
        // Build Top 3 list (unique articles with actual awards ONLY - no runner-ups)
        const top3Ids = [];
        const usedForTop3 = new Set();
        // Get actual award winners (1st place only)
        const headlineWinnerId = byCombo.length > 0 ? byCombo[0].id : null;
        const zeroEchoWinnerId = byZS.length > 0 ? byZS[0].id : null;
        const hotTopicWinnerId = byIS.length > 0 ? byIS[0].id : null;
        // Slot 1: Today's Headline (always first)
        if (headlineWinnerId && !usedForTop3.has(headlineWinnerId)) {
            top3Ids.push(headlineWinnerId);
            usedForTop3.add(headlineWinnerId);
        }
        // Slot 2: Zero Echo Award (only if different from Headline)
        if (zeroEchoWinnerId && !usedForTop3.has(zeroEchoWinnerId)) {
            top3Ids.push(zeroEchoWinnerId);
            usedForTop3.add(zeroEchoWinnerId);
        }
        // Slot 3: Hot Topic (only if different from above)
        if (hotTopicWinnerId && !usedForTop3.has(hotTopicWinnerId)) {
            top3Ids.push(hotTopicWinnerId);
            usedForTop3.add(hotTopicWinnerId);
        }
        // Get article objects for logging
        const headlineWinner = headlineWinnerId ? articlesWithSize.find((a)=>a.id === headlineWinnerId) : null;
        const zeroEchoWinner = zeroEchoWinnerId ? articlesWithSize.find((a)=>a.id === zeroEchoWinnerId) : null;
        const hotTopicWinner = hotTopicWinnerId ? articlesWithSize.find((a)=>a.id === hotTopicWinnerId) : null;
        console.log(`[Awards] Today's Headline: ${headlineWinner?.id?.substring(0, 30)}`);
        console.log(`[Awards] Zero Echo Award: ${zeroEchoWinner?.id?.substring(0, 30)}`);
        console.log(`[Awards] Hot Topic: ${hotTopicWinner?.id?.substring(0, 30)}`);
        // Phase 0: Place Top 3 Award Winners
        let lastPlacedRow = 0;
        for(let i = 0; i < top3Ids.length; i++){
            const article = articlesWithSize.find((a)=>a.id === top3Ids[i]);
            if (!article) continue;
            // Attach awards to article
            article.awards = awardMap.get(article.id) || [];
            // First article (Headline) gets full width
            if (i === 0) {
                article.cols = 10;
            }
            const p = this.placeArticle(article, lastPlacedRow);
            if (p) {
                placed.add(article.id);
                finalOrder.push(article);
                if (i === 0) {
                    lastPlacedRow = p.row + p.article.rows;
                } else {
                    lastPlacedRow = p.row;
                }
            }
        }
        console.log(`[Phase 0] After Top 3: finalOrder=${finalOrder.length}, placed=${placed.size}`);
        // Phase 1: Place remaining primary articles (greedy)
        const primaryCount = Math.ceil(sortedArticles.length * 0.7); // 70% are primary
        for(let i = 0; i < sortedArticles.length; i++){
            const article = sortedArticles[i];
            if (placed.has(article.id)) continue;
            const p = this.placeArticle(article);
            if (p) {
                placed.add(article.id);
                finalOrder.push(article);
            }
        }
        // Phase 2: Detect gaps and fill with remaining articles (ZS priority)
        const remainingArticles = sortedArticles.filter((a)=>!placed.has(a.id));
        // Multiple passes to fill gaps
        for(let pass = 0; pass < 3; pass++){
            const gaps = this.detectGaps(6);
            for (const gap of gaps){
                const candidates = remainingArticles.filter((a)=>!placed.has(a.id));
                const filler = this.findFillerForGap(gap, candidates);
                if (filler) {
                    // Place at gap position
                    if (this.canPlace(gap.col, gap.row, filler.cols, filler.rows)) {
                        this.markOccupied(gap.col, gap.row, filler.cols, filler.rows, filler.id);
                        placed.add(filler.id);
                        finalOrder.push(filler);
                    }
                }
            }
        }
        // Phase 3: Append any remaining articles
        for (const article of remainingArticles){
            if (!placed.has(article.id)) {
                this.placeArticle(article);
                placed.add(article.id);
                finalOrder.push(article);
            }
        }
        console.log(`[LayoutOptimizer] Input: ${articles.length}, Output: ${finalOrder.length}`);
        return finalOrder;
    }
    // Get debug info about current grid state
    getGridStats() {
        let occupiedCells = 0;
        const totalCells = this.nextRow * this.gridCols;
        for(let r = 0; r < this.nextRow; r++){
            for(let c = 0; c < this.gridCols; c++){
                if (this.grid[r][c].occupied) occupiedCells++;
            }
        }
        return {
            occupiedCells,
            totalCells,
            fillRate: totalCells > 0 ? occupiedCells / totalCells : 0
        };
    }
}
// Singleton instance for convenience
let optimizerInstance = null;
const getLayoutOptimizer = (cols = 10)=>{
    if (!optimizerInstance) {
        optimizerInstance = new LayoutOptimizer(cols);
    }
    return optimizerInstance;
};
const optimizeArticleOrder = (articles)=>{
    const optimizer = new LayoutOptimizer(10);
    return optimizer.optimizeLayout(articles);
};
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http2 [external] (http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[project]/src/lib/firebase.ts [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "app",
    ()=>app,
    "db",
    ()=>db
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$firebase$2f$app$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/firebase/app/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$app$2f$dist$2f$esm$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@firebase/app/dist/esm/index.esm.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$firebase$2f$firestore$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/firebase/firestore/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@firebase/firestore/dist/index.node.mjs [app-rsc] (ecmascript)");
;
;
const firebaseConfig = {
    apiKey: ("TURBOPACK compile-time value", "AIzaSyAEEETL2OND89Wp3jz0MTNBdNzaVfvQfGg"),
    authDomain: ("TURBOPACK compile-time value", "zeroechodaily-fa928.firebaseapp.com"),
    projectId: ("TURBOPACK compile-time value", "zeroechodaily-fa928"),
    storageBucket: ("TURBOPACK compile-time value", "zeroechodaily-fa928.firebasestorage.app"),
    messagingSenderId: ("TURBOPACK compile-time value", "48848484312"),
    appId: ("TURBOPACK compile-time value", "1:48848484312:web:40ff615aabb494accca4ad")
};
// Initialize Firebase
const app = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$app$2f$dist$2f$esm$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getApps"])().length ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$app$2f$dist$2f$esm$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["initializeApp"])(firebaseConfig) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$app$2f$dist$2f$esm$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getApp"])();
const db = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFirestore"])(app);
;
}),
"[project]/src/lib/firestoreService.ts [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "checkLatestUpdate",
    ()=>checkLatestUpdate,
    "fetchArticlesByIssueId",
    ()=>fetchArticlesByIssueId,
    "fetchPublishedIssues",
    ()=>fetchPublishedIssues
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firebase$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/firebase.ts [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$firebase$2f$firestore$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/firebase/firestore/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@firebase/firestore/dist/index.node.mjs [app-rsc] (ecmascript)");
;
;
const COLLECTION_PUBLICATIONS = 'publications';
async function fetchPublishedIssues() {
    try {
        console.log('ðŸ”¥ [Firestore] Fetching _meta document...');
        // _meta ë¬¸ì„œì—ì„œ ëª©ë¡ ì¡°íšŒ (1 READ)
        const metaDoc = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDoc"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["doc"])(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firebase$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["db"], COLLECTION_PUBLICATIONS, '_meta'));
        if (!metaDoc.exists()) {
            console.log('âš ï¸ [Firestore] _meta document not found, falling back to full scan...');
            return await fetchPublishedIssuesFallback();
        }
        const metaData = metaDoc.data();
        const latestUpdate = metaData.latest_updated_at || null;
        // released ìƒíƒœì¸ ê²ƒë§Œ í•„í„°ë§
        const releasedMeta = (metaData.issues || []).filter((i)=>i.status === 'released');
        // Issue í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (ìƒì„¸ ì •ë³´ëŠ” íšŒì°¨ ë¬¸ì„œì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨)
        const issues = releasedMeta.map((meta)=>({
                id: meta.code,
                edition_code: meta.code,
                edition_name: meta.name,
                article_count: meta.count,
                published_at: meta.updated_at,
                updated_at: meta.updated_at,
                status: meta.status,
                date: meta.code.replace(/_\d+$/, '').replace(/(\d{2})(\d{2})(\d{2})/, '20$1-$2-$3')
            }));
        // published_at ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
        issues.sort((a, b)=>{
            const dateA = new Date(a.published_at || 0).getTime();
            const dateB = new Date(b.published_at || 0).getTime();
            return dateB - dateA;
        });
        console.log(`âœ… [Firestore] Found ${issues.length} released issues from _meta`);
        return {
            issues,
            latestUpdatedAt: latestUpdate
        };
    } catch (error) {
        console.error('âŒ [Firestore] Failed to fetch _meta:', error);
        return await fetchPublishedIssuesFallback();
    }
}
/**
 * í´ë°±: ì „ì²´ publications ìŠ¤ìº” (ê¸°ì¡´ ë°©ì‹, _meta ì—†ì„ ë•Œ)
 */ async function fetchPublishedIssuesFallback() {
    try {
        console.log('ðŸ”¥ [Firestore] Fallback: scanning all publications...');
        const snapshot = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocs"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["collection"])(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firebase$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["db"], COLLECTION_PUBLICATIONS));
        let allIssues = [];
        let latestUpdate = null;
        snapshot.forEach((docSnap)=>{
            const docId = docSnap.id;
            // _meta, _article_ids ì œì™¸
            if (docId.startsWith('_')) return;
            const data = docSnap.data();
            allIssues.push({
                id: docSnap.id,
                ...data
            });
        });
        const releasedIssues = allIssues.filter((issue)=>issue.status === 'released');
        releasedIssues.sort((a, b)=>{
            const dateA = new Date(a.published_at || 0).getTime();
            const dateB = new Date(b.published_at || 0).getTime();
            return dateB - dateA;
        });
        for (const issue of releasedIssues){
            if (issue.updated_at) {
                if (!latestUpdate || new Date(issue.updated_at) > new Date(latestUpdate)) {
                    latestUpdate = issue.updated_at;
                }
            }
        }
        console.log(`âœ… [Firestore] Fallback found ${releasedIssues.length} released issues`);
        return {
            issues: releasedIssues,
            latestUpdatedAt: latestUpdate
        };
    } catch (error) {
        console.error('âŒ [Firestore] Fallback failed:', error);
        return {
            issues: [],
            latestUpdatedAt: null
        };
    }
}
async function fetchArticlesByIssueId(issueId) {
    try {
        // console.log(`ðŸ”¥ [Firestore] Fetching articles for issue: ${issueId}`);
        // íšŒì°¨ ë¬¸ì„œì—ì„œ ì§ì ‘ articles ë°°ì—´ ì½ê¸° (1 READ)
        const pubDoc = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDoc"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["doc"])(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firebase$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["db"], COLLECTION_PUBLICATIONS, issueId));
        if (!pubDoc.exists()) {
            console.log(`âŒ [Firestore] Publication not found: ${issueId}`);
            return [];
        }
        const pubData = pubDoc.data();
        const articles = pubData.articles || [];
        // article_id í•„ë“œ ì •ê·œí™”
        return articles.map((art)=>({
                ...art,
                article_id: art.id || art.article_id,
                id: art.id || art.article_id
            }));
    } catch (error) {
        console.error(`âŒ [Firestore] Failed to fetch articles for ${issueId}:`, error);
        return [];
    }
}
async function checkLatestUpdate() {
    try {
        // _meta ë¬¸ì„œì—ì„œ latest_updated_at í™•ì¸ (1 READ)
        const metaDoc = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDoc"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$firebase$2f$firestore$2f$dist$2f$index$2e$node$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["doc"])(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firebase$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["db"], COLLECTION_PUBLICATIONS, '_meta'));
        if (metaDoc.exists()) {
            const metaData = metaDoc.data();
            return metaData.latest_updated_at || null;
        }
        // _meta ì—†ìœ¼ë©´ í´ë°±
        console.log('âš ï¸ [Firestore] _meta not found, falling back...');
        const { latestUpdatedAt } = await fetchPublishedIssuesFallback();
        return latestUpdatedAt;
    } catch (error) {
        console.error('âŒ [Firestore] checkLatestUpdate failed:', error);
        return null;
    }
}
}),
"[project]/src/lib/serverCache.ts [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getPublicationsWithServerCache",
    ()=>getPublicationsWithServerCache,
    "invalidateServerCache",
    ()=>invalidateServerCache
]);
/**
 * ì„œë²„ ì‚¬ì´ë“œ ê³µìœ  ìºì‹œ
 * - ëª¨ë“  ì‚¬ìš©ìžê°€ ê°™ì€ ìºì‹œ ê³µìœ 
 * - ì ‘ì† ì‹œ ìµœì‹  ë²„ì „ í™•ì¸ í›„ ì¡°ê±´ë¶€ ê°±ì‹ 
 * - [Refactor] 2025-12: Backend API ì˜ì¡´ì„± ì œê±° -> Firestore ì§ì ‘ ì¡°íšŒ
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$layoutOptimizer$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/utils/layoutOptimizer.ts [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firestoreService$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/firestoreService.ts [app-rsc] (ecmascript)");
;
;
// ì„œë²„ ë©”ëª¨ë¦¬ ê³µìœ  ìºì‹œ (ëª¨ë“  ìš”ì²­ì´ ê³µìœ )
let serverCache = null;
/**
 * ë°±ì—”ë“œ(DB)ì—ì„œ ìµœì‹  ë²„ì „ í™•ì¸
 */ async function checkForUpdates() {
    try {
        const currentVersion = serverCache?.lastUpdatedAt;
        const latestVersion = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firestoreService$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["checkLatestUpdate"])();
        // DBì— ë°ì´í„°ê°€ ì—†ê±°ë‚˜ ì—ëŸ¬ë©´ ë³€ê²½ ì—†ëŠ” ê²ƒìœ¼ë¡œ ì²˜ë¦¬ (ì•ˆì „ìž¥ì¹˜)
        if (!latestVersion) {
            return {
                changed: false,
                latestUpdatedAt: currentVersion || null
            };
        }
        const changed = currentVersion !== latestVersion;
        if (changed) {
            console.log(`[ServerCache] Detect Change: ${currentVersion} -> ${latestVersion}`);
        } else {
            console.log(`[ServerCache] No Change (Latest: ${latestVersion})`);
        }
        return {
            changed,
            latestUpdatedAt: latestVersion
        };
    } catch (error) {
        console.error('[ServerCache] Check error:', error);
        return {
            changed: true,
            latestUpdatedAt: null
        };
    }
}
/**
 * ì „ì²´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (Firestore ì§ì ‘ ì¡°íšŒ)
 */ async function fetchAllData() {
    console.log('[ServerCache] Fetching fresh data from Firestore (Direct)...');
    try {
        // 1. íšŒì°¨ ëª©ë¡ ì¡°íšŒ
        const { issues, latestUpdatedAt } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firestoreService$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fetchPublishedIssues"])();
        if (issues.length === 0) {
            console.warn('[ServerCache] No issues found.');
            return {
                issues: [],
                articles: [],
                latestUpdatedAt: null
            };
        }
        // 2. ê° íšŒì°¨ì˜ ê¸°ì‚¬ ì¡°íšŒ (ë³‘ë ¬)
        const articlePromises = issues.map(async (issue)=>{
            try {
                const articles = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$firestoreService$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fetchArticlesByIssueId"])(issue.id);
                // Layout Optimizer ì ìš© ë° ë©”íƒ€ë°ì´í„° ì£¼ìž…
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$utils$2f$layoutOptimizer$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["optimizeArticleOrder"])(articles).map((article)=>({
                        ...article,
                        publish_id: issue.id,
                        edition_name: issue.edition_name,
                        edition_code: issue.edition_code
                    }));
            } catch (err) {
                console.error(`[ServerCache] Failed to fetch articles for issue ${issue.id}`, err);
                return [];
            }
        });
        const articlesArrays = await Promise.all(articlePromises);
        const allArticles = articlesArrays.flat();
        console.log(`[ServerCache] Fetched ${issues.length} issues, ${allArticles.length} articles`);
        return {
            issues,
            articles: allArticles,
            latestUpdatedAt
        };
    } catch (error) {
        console.error('[ServerCache] Fetch error:', error);
        return {
            issues: [],
            articles: [],
            latestUpdatedAt: null
        };
    }
}
async function getPublicationsWithServerCache() {
    // ìºì‹œê°€ ì—†ìœ¼ë©´ ì „ì²´ fetch
    if (!serverCache) {
        const data = await fetchAllData();
        serverCache = {
            issues: data.issues,
            articles: data.articles,
            lastUpdatedAt: data.latestUpdatedAt
        };
        return {
            issues: data.issues,
            articles: data.articles
        };
    }
    // ìºì‹œê°€ ìžˆìœ¼ë©´ ë³€ê²½ ì²´í¬
    const { changed, latestUpdatedAt } = await checkForUpdates();
    if (!changed) {
        // console.log('[ServerCache] Using cached data âœ…');
        return {
            issues: serverCache.issues,
            articles: serverCache.articles
        };
    }
    // ë³€ê²½ ìžˆìœ¼ë©´ ì „ì²´ ê°±ì‹ 
    console.log('[ServerCache] Data changed, refreshing...');
    const data = await fetchAllData();
    serverCache = {
        issues: data.issues,
        articles: data.articles,
        lastUpdatedAt: data.latestUpdatedAt || latestUpdatedAt
    };
    return {
        issues: data.issues,
        articles: data.articles
    };
}
function invalidateServerCache() {
    serverCache = null;
    console.log('[ServerCache] Invalidated');
}
}),
"[project]/src/app/page.tsx [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Home,
    "dynamic",
    ()=>dynamic,
    "revalidate",
    ()=>revalidate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$components$2f$HomePageClient$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/components/HomePageClient.tsx [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$serverCache$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/serverCache.ts [app-rsc] (ecmascript)");
;
;
;
const dynamic = 'force-dynamic';
const revalidate = 0;
async function Home() {
    // ì„œë²„ ê³µìœ  ìºì‹œ ì‚¬ìš©: ë³€ê²½ ìžˆì„ ë•Œë§Œ Firestore ì¡°íšŒ
    const { issues, articles } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$serverCache$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPublicationsWithServerCache"])();
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$components$2f$HomePageClient$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"], {
        articles: articles,
        issues: issues
    }, void 0, false, {
        fileName: "[project]/src/app/page.tsx",
        lineNumber: 12,
        columnNumber: 10
    }, this);
}
}),
"[project]/src/app/page.tsx [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/src/app/page.tsx [app-rsc] (ecmascript)"));
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__b68d3e1f._.js.map